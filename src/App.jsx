import WeatherForm from "./components/WeatherForm";
import WeatherCard from "./components/WeatherCard";
import { useEffect, useState } from "react";
import "./App.css";
import "../src/index.css";

const API_KEY = import.meta.env.VITE_API_KEY;

function App({ theme, setTheme }) {
    const [cards, setCards] = useState([]);
    useEffect(() => {
        document.documentElement.setAttribute("data-theme", theme);
        localStorage.setItem("theme", theme);
    }, [theme]);


    // ---------- API HELPERS ----------
    async function getWeatherByCity(city) {
        const url = `https://api.openweathermap.org/data/2.5/weather?q=${city}&appid=${API_KEY}&units=metric`;
        const response = await fetch(url);
        if (!response.ok) throw new Error("City not found");
        return await response.json();
    }

    async function getWeatherByZip(zip) {
        const url = `https://api.openweathermap.org/data/2.5/weather?zip=${zip}&appid=${API_KEY}&units=metric`;
        const response = await fetch(url);
        if (!response.ok) throw new Error("Invalid Zip Code");
        return await response.json();
    }

    async function getWeatherByCoords(lat, lon) {
        const url = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${API_KEY}&units=metric`;
        const response = await fetch(url);
        if (!response.ok) throw new Error("Invalid coordinates");
        return await response.json();
    }

    // ---------- FETCH USER LOCATION ----------
    async function fetchUserLocationWeather() {
        return new Promise((resolve, reject) => {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    async (pos) => {
                        try {
                            const data = await getWeatherByCoords(
                                pos.coords.latitude,
                                pos.coords.longitude
                            );
                            resolve(data);
                        } catch (err) {
                            reject(err);
                        }
                    },
                    (err) => reject(err)
                );
            } else {
                reject(new Error("Geolocation not supported"));
            }
        });
    }

    // ---------- LOAD CARDS ON MOUNT ----------
    useEffect(() => {
        const saved = localStorage.getItem("weatherCards");
        let parsed = saved ? JSON.parse(saved) : [];

        // Always try to fetch live location
        fetchUserLocationWeather()
            .then((weather) => {
                // Check if this location already exists in saved
                const exists = parsed.some((w) => w.id === weather.id);
                if (!exists) {
                    parsed = [weather, ...parsed]; // put location card first
                }
                setCards(parsed);
            })
            .catch((err) => {
                console.error("Location error:", err);
                setCards(parsed); // fallback to saved only
            });
    }, []);

    // ---------- SAVE TO LOCAL STORAGE ----------
    useEffect(() => {
        if (cards.length > 0) {
            localStorage.setItem("weatherCards", JSON.stringify(cards));
        }
    }, [cards]);

    // ---------- SEARCH HANDLER ----------
    const handleSearch = async (data) => {
        try {
            let weather;
            if (data.type === "city") {
                weather = await getWeatherByCity(data.value);
            } else if (data.type === "zip") {
                weather = await getWeatherByZip(data.value);
            } else if (data.type === "coords") {
                weather = await getWeatherByCoords(data.lat, data.lon);
            }
            if (weather) setCards((prev) => [...prev, weather]);
        } catch (err) {
            console.error("Search error:", err);
        }
    };

    // ---------- FORECAST ----------
    // async function getForecastByCity(city) {
    //     const url = `https://api.openweathermap.org/data/2.5/forecast?q=${city}&appid=${API_KEY}&units=metric`;
    //     const response = await fetch(url);
    //     if (!response.ok) throw new Error("City not found");
    //     const data = await response.json();

    //     const today = new Date().getDate();
    //     return data.list.filter(
    //         (item) => new Date(item.dt_txt).getDate() <= today + 3
    //     );
    // }

    //generated by AI for 3-day forecast by appling logic to show forecast data
    // fetch 3-day forecast (grouped by day)
    async function getForecastByCity(city) {
        const url = `https://api.openweathermap.org/data/2.5/forecast?q=${city}&appid=${API_KEY}&units=metric`;

        const response = await fetch(url);
        if (!response.ok) throw new Error("City not found");
        const data = await response.json();

        // Group by day
        const grouped = {};
        data.list.forEach((item) => {
            const date = new Date(item.dt_txt);
            const day = date.toLocaleDateString("en-US", {
                weekday: "short",
                day: "numeric",
                month: "short",
            });

            if (!grouped[day]) grouped[day] = [];
            grouped[day].push(item);
        });

        // Take only first 3 days
        const days = Object.keys(grouped).slice(0, 3);

        // Summarize each day
        const forecast3Days = days.map((day) => {
            const entries = grouped[day];
            const temps = entries.map((e) => e.main.temp);
            const descriptions = entries.map((e) => e.weather[0].description);

            // Pick most common description
            const desc =
                descriptions.sort(
                    (a, b) =>
                        descriptions.filter((v) => v === a).length -
                        descriptions.filter((v) => v === b).length
                ).pop() || descriptions[0];

            return {
                day,
                min: Math.min(...temps).toFixed(1),
                max: Math.max(...temps).toFixed(1),
                desc,
                icon: entries[0].weather[0].icon, // just pick first icon of the day
            };
        });

        return forecast3Days;
    }

    const handleForecast = async (cityName) => {
        const forecast = await getForecastByCity(cityName);
        return forecast;
    };

    return (
        <div>
            {/* <Navbar /> */}
            <div className="form-div">
                <div className="form-container">
                    <WeatherForm onSearch={handleSearch} />
                </div>
            </div>
            <div>
                <div className="card-container">
                    {cards.map((weather, index) => (
                        <WeatherCard
                            key={weather.id || weather.name}
                            weather={weather}
                            onDelete={(idOrName) => {
                                const updated = cards.filter(
                                    (w) => (w.id || w.name) !== idOrName
                                );
                                setCards(updated);
                                localStorage.setItem("weatherCards", JSON.stringify(updated));
                            }}
                            onForecast={handleForecast}
                        />
                    ))}
                </div>
            </div>
        </div>
    );
}

export default App;
